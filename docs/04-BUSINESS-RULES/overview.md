# üíº Business Rules - Regras de Neg√≥cio

> Regras de neg√≥cio, fluxos e l√≥gica do sistema

---

## üìã √çndice
- [Conceitos Fundamentais](#conceitos-fundamentais)
- [Regras de Status](#regras-de-status)
- [Regras de Pagamento](#regras-de-pagamento)
- [Regras de Comiss√£o](#regras-de-comiss√£o)
- [Fluxos Principais](#fluxos-principais)

---

## üéØ Conceitos Fundamentais

### 1. Ciclo de Vida do Usu√°rio

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Prospec√ß√£o  ‚îÇ Lead cadastrado
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ Convers√£o
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Inativo   ‚îÇ Usu√°rio criado, sem pagamento
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ Primeiro Pagamento (PRIMEIRO)
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    Ativo    ‚îÇ dias_para_vencer >= 1
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚îú‚îÄ‚ñ∂ Renova√ß√£o (RECORRENTE) ‚Üí Continua Ativo
       ‚îÇ
       ‚îú‚îÄ‚ñ∂ Vencimento sem pagamento ‚Üí Em Atraso
       ‚îÇ
       ‚îî‚îÄ‚ñ∂ Cancelamento ‚Üí Churn ‚Üí Inativo
```

### 2. Status do Usu√°rio

| Status | Condi√ß√£o | Descri√ß√£o |
|--------|----------|-----------|
| **ATIVO** | `diasParaVencer >= 1` | Assinatura v√°lida |
| **EM_ATRASO** | `diasParaVencer < 0` | Vencido, sem pagamento |
| **INATIVO** | Manual ou churn | Cancelado ou sem atividade |
| **HISTORICO** | Antigo | Usu√°rio hist√≥rico do sistema |

### 3. Flags Autom√°ticas

| Flag | Condi√ß√£o | Uso |
|------|----------|-----|
| **venceHoje** | `diasParaVencer === 0` | Alerta de vencimento hoje |
| **prox7Dias** | `diasParaVencer >= 1 && <= 7` | Vence na pr√≥xima semana |
| **emAtraso** | `diasParaVencer < 0` | Assinatura vencida |
| **entrou** | Primeiro pagamento | Novo assinante |
| **renovou** | Pagamento recorrente | Renova√ß√£o |
| **churn** | Cancelamento | Cliente perdido |

---

## üìè Regras de Status

### C√°lculo Autom√°tico

**Executado por:** Job di√°rio `atualizarFlags.ts`

```typescript
// C√°lculo de dias_para_vencer
diasParaVencer = differenceInDays(dataVenc, hoje);

// Status Final
if (diasParaVencer >= 1) {
  statusFinal = 'ATIVO';
} else if (diasParaVencer < 0) {
  statusFinal = 'EM_ATRASO';
} else {
  // Mant√©m status atual se for INATIVO ou HISTORICO
}

// Flags
venceHoje = (diasParaVencer === 0);
prox7Dias = (diasParaVencer >= 1 && diasParaVencer <= 7);
emAtraso = (diasParaVencer < 0);
```

### Atualiza√ß√£o de Status

**Quando √© atualizado:**
1. ‚úÖ Diariamente via job `atualizarFlags.ts`
2. ‚úÖ Ao criar pagamento (PRIMEIRO ou RECORRENTE)
3. ‚úÖ Ao renovar na agenda
4. ‚úÖ Ao cancelar (churn)

---

## üí∞ Regras de Pagamento

### Tipos de Pagamento

#### 1. PRIMEIRO (Entrada)

**Condi√ß√£o:** `usuario.ciclo === 0`

**A√ß√µes autom√°ticas:**
```typescript
1. Define usuario.entrou = true
2. Incrementa usuario.ciclo para 1
3. Define usuario.ativoAtual = true
4. Calcula dataVenc = dataPagto + 30 dias
5. Calcula comiss√£o de PRIMEIRO (se eleg√≠vel)
6. Define usuario.statusFinal = 'ATIVO'
7. Atualiza flags (venceHoje, prox7Dias, emAtraso)
8. Cria registro de Comissao (se eleg√≠vel)
```

**Exemplo:**
```typescript
// Usu√°rio novo (ciclo = 0)
const pagamento = {
  usuarioId: 1,
  valor: 100,
  dataPagto: '2025-01-15',
  regraTipo: 'PRIMEIRO',  // ‚Üê Determinado automaticamente
};

// Ap√≥s processamento:
usuario = {
  ciclo: 1,              // 0 ‚Üí 1
  dataVenc: '2025-02-14', // +30 dias
  entrou: true,
  ativoAtual: true,
  statusFinal: 'ATIVO',
};
```

#### 2. RECORRENTE (Renova√ß√£o)

**Condi√ß√£o:** `usuario.ciclo > 0`

**A√ß√µes autom√°ticas:**
```typescript
1. Define usuario.renovou = true
2. Incrementa usuario.ciclo (+1)
3. Atualiza dataVenc = dataPagto + 30 dias
4. Calcula comiss√£o de RECORRENTE (se eleg√≠vel)
5. Atualiza statusFinal = 'ATIVO'
6. Reseta flag emAtraso = false
7. Cria registro de Comissao (se eleg√≠vel)
```

**Exemplo:**
```typescript
// Usu√°rio existente (ciclo = 5)
const pagamento = {
  usuarioId: 1,
  valor: 100,
  dataPagto: '2025-02-15',
  regraTipo: 'RECORRENTE',  // ‚Üê Determinado automaticamente
};

// Ap√≥s processamento:
usuario = {
  ciclo: 6,              // 5 ‚Üí 6
  dataVenc: '2025-03-17', // +30 dias
  renovou: true,
  statusFinal: 'ATIVO',
  emAtraso: false,
};
```

### Regras de Valida√ß√£o

```typescript
// 1. Valor deve ser positivo
if (valor <= 0) {
  throw new Error('Valor deve ser maior que zero');
}

// 2. Usu√°rio deve existir
const usuario = await prisma.usuario.findUnique({ where: { id: usuarioId } });
if (!usuario) {
  throw new Error('Usu√°rio n√£o encontrado');
}

// 3. Data de pagamento n√£o pode ser futura
if (dataPagto > hoje) {
  throw new Error('Data de pagamento n√£o pode ser futura');
}

// 4. M√©todo e conta devem ser v√°lidos
if (!metodo || !conta) {
  throw new Error('M√©todo e conta s√£o obrigat√≥rios');
}
```

---

## üí∏ Regras de Comiss√£o

### Elegibilidade

**Usu√°rio eleg√≠vel se:**
1. ‚úÖ Tem indicador definido (`usuario.indicador !== null`)
2. ‚úÖ Tem regraTipo definido (`usuario.regraTipo !== null`)
3. ‚úÖ Tem regraValor > 0 (`usuario.regraValor > 0`)

### C√°lculo

```typescript
// Tipo 1: PRIMEIRO (entrada)
if (regraTipo === 'PRIMEIRO') {
  comissaoValor = (valor * regraValor) / 100;
}

// Tipo 2: RECORRENTE (renova√ß√£o)
if (regraTipo === 'RECORRENTE') {
  comissaoValor = (valor * regraValor) / 100;
}

// Se eleg√≠vel, cria registro de Comissao
if (comissaoValor > 0) {
  await prisma.comissao.create({
    data: {
      pagamentoId: pagamento.id,
      indicador: usuario.indicador,
      regraTipo: pagamento.regraTipo,
      valor: comissaoValor,
      mesRef: format(pagamento.dataPagto, 'yyyy-MM'),
    },
  });
}
```

### Consolida√ß√£o

**Comiss√µes s√£o consolidadas por:**
- ‚úÖ Indicador
- ‚úÖ Tipo de regra (PRIMEIRO/RECORRENTE)
- ‚úÖ M√™s de refer√™ncia

**Query de consolida√ß√£o:**
```typescript
// Comiss√µes por indicador (m√™s atual)
const comissoes = await prisma.comissao.groupBy({
  by: ['indicador', 'regraTipo'],
  where: {
    mesRef: '2025-01',
  },
  _sum: {
    valor: true,
  },
  _count: {
    id: true,
  },
});

// Resultado:
[
  {
    indicador: 'Jo√£o Silva',
    regraTipo: 'PRIMEIRO',
    _sum: { valor: 500 },
    _count: { id: 5 },
  },
  {
    indicador: 'Jo√£o Silva',
    regraTipo: 'RECORRENTE',
    _sum: { valor: 1200 },
    _count: { id: 15 },
  },
]
```

---

## üîÑ Fluxos Principais

### 1. Fluxo de Convers√£o (Lead ‚Üí Usu√°rio)

```typescript
// 1. Lead cadastrado na Prospec√ß√£o
const lead = await prisma.prospeccao.create({
  data: {
    email: 'lead@example.com',
    nome: 'Lead Exemplo',
    indicador: 'Jo√£o Silva',
    origem: 'Website',
  },
});

// 2. Gestor converte lead
const usuario = await prisma.usuario.create({
  data: {
    emailLogin: lead.email,
    nomeCompleto: lead.nome,
    indicador: lead.indicador,
    statusFinal: 'INATIVO',  // ‚Üê Ainda sem pagamento
    ciclo: 0,
  },
});

// 3. Vincula lead ao usu√°rio
await prisma.prospeccao.update({
  where: { id: lead.id },
  data: {
    convertido: true,
    usuarioId: usuario.id,
  },
});

// 4. Registrar primeiro pagamento (ver Fluxo 2)
```

### 2. Fluxo de Primeiro Pagamento

```typescript
// 1. Usu√°rio existente sem pagamentos (ciclo = 0)
const usuario = await prisma.usuario.findUnique({
  where: { id: 1 },
});

// ciclo = 0 ‚Üí PRIMEIRO pagamento

// 2. Service processa pagamento
const pagamento = await pagamentoService.create({
  usuarioId: 1,
  valor: 100,
  dataPagto: new Date('2025-01-15'),
  metodo: 'PIX',
  conta: 'Conta Principal',
});

// 3. A√ß√µes autom√°ticas (dentro de transaction):
await prisma.$transaction(async (tx) => {
  // a) Cria pagamento
  const pag = await tx.pagamento.create({
    data: {
      usuarioId: 1,
      valor: 100,
      regraTipo: 'PRIMEIRO',  // ‚Üê Determinado pelo ciclo = 0
      comissaoValor: 10,      // 10% de 100
      elegivelComissao: true,
    },
  });

  // b) Atualiza usu√°rio
  await tx.usuario.update({
    where: { id: 1 },
    data: {
      ciclo: 1,                      // 0 ‚Üí 1
      dataPagto: new Date('2025-01-15'),
      dataVenc: new Date('2025-02-14'), // +30 dias
      statusFinal: 'ATIVO',
      entrou: true,
      ativoAtual: true,
      diasParaVencer: 30,
    },
  });

  // c) Cria comiss√£o
  await tx.comissao.create({
    data: {
      pagamentoId: pag.id,
      indicador: usuario.indicador,
      regraTipo: 'PRIMEIRO',
      valor: 10,
      mesRef: '2025-01',
    },
  });
});
```

### 3. Fluxo de Renova√ß√£o (via Agenda)

```typescript
// 1. Sistema popula Agenda automaticamente
// (usu√°rios com dataVenc nos pr√≥ximos 30 dias)
const agenda = await prisma.agenda.create({
  data: {
    usuarioId: 1,
    dataVenc: new Date('2025-02-14'),
    ciclo: 1,
    status: 'ATIVO',
  },
});

// 2. Gestor marca como "Renovado" na tela de Agenda
await agendaService.marcarRenovado(agenda.id, {
  valor: 100,
  dataPagto: new Date('2025-02-14'),
  metodo: 'PIX',
  conta: 'Conta Principal',
});

// 3. Service processa (dentro de transaction):
await prisma.$transaction(async (tx) => {
  // a) Atualiza agenda
  await tx.agenda.update({
    where: { id: agenda.id },
    data: {
      renovou: true,
      status: 'INATIVO',  // Remove da agenda
    },
  });

  // b) Cria pagamento RECORRENTE
  const pagamento = await tx.pagamento.create({
    data: {
      usuarioId: 1,
      valor: 100,
      regraTipo: 'RECORRENTE',
      comissaoValor: 5,  // 5% de 100
      dataPagto: new Date('2025-02-14'),
    },
  });

  // c) Atualiza usu√°rio
  await tx.usuario.update({
    where: { id: 1 },
    data: {
      ciclo: 2,                      // 1 ‚Üí 2
      dataVenc: new Date('2025-03-16'), // +30 dias
      renovou: true,
      statusFinal: 'ATIVO',
      emAtraso: false,
    },
  });

  // d) Cria comiss√£o
  await tx.comissao.create({
    data: {
      pagamentoId: pagamento.id,
      indicador: usuario.indicador,
      regraTipo: 'RECORRENTE',
      valor: 5,
      mesRef: '2025-02',
    },
  });
});
```

### 4. Fluxo de Churn (Cancelamento)

```typescript
// 1. Gestor marca como "Cancelado" na Agenda
await agendaService.marcarCancelado(agenda.id, {
  motivo: 'Pre√ßo alto',
});

// 2. Service processa (dentro de transaction):
await prisma.$transaction(async (tx) => {
  // a) Atualiza agenda
  await tx.agenda.update({
    where: { id: agenda.id },
    data: {
      cancelou: true,
      status: 'INATIVO',
    },
  });

  // b) Cria registro de Churn
  await tx.churn.create({
    data: {
      usuarioId: 1,
      dataChurn: new Date(),
      motivo: 'Pre√ßo alto',
      revertido: false,
    },
  });

  // c) Atualiza usu√°rio
  await tx.usuario.update({
    where: { id: 1 },
    data: {
      churn: true,
      statusFinal: 'INATIVO',
      ativoAtual: false,
    },
  });
});

// 3. (Opcional) Reverter churn
await churnService.reverter(churn.id);

// Service processa:
await prisma.$transaction(async (tx) => {
  await tx.churn.update({
    where: { id: churn.id },
    data: { revertido: true },
  });

  await tx.usuario.update({
    where: { id: 1 },
    data: {
      churn: false,
      statusFinal: 'ATIVO',  // Se ainda v√°lido
      ativoAtual: true,
    },
  });
});
```

---

## üéØ Regras de Neg√≥cio por M√≥dulo

### Usu√°rios
- ‚úÖ Email √∫nico (n√£o pode duplicar)
- ‚úÖ Status calculado automaticamente (n√£o edit√°vel manualmente)
- ‚úÖ Ciclo incrementa apenas com pagamentos
- ‚úÖ dataVenc sempre +30 dias do √∫ltimo pagamento

### Pagamentos
- ‚úÖ Valor sempre positivo
- ‚úÖ Data n√£o pode ser futura
- ‚úÖ regraTipo determinado automaticamente pelo ciclo
- ‚úÖ Comiss√£o calculada automaticamente

### Agenda
- ‚úÖ Populada automaticamente com vencimentos futuros
- ‚úÖ Status ATIVO = ainda n√£o processado
- ‚úÖ renovado/cancelado mutuamente exclusivos
- ‚úÖ Renova√ß√£o cria pagamento RECORRENTE

### Churn
- ‚úÖ Marca usu√°rio como INATIVO
- ‚úÖ Pode ser revertido
- ‚úÖ Motivo √© obrigat√≥rio

### Comiss√µes
- ‚úÖ Criadas automaticamente com pagamentos
- ‚úÖ Consolidadas por indicador + tipo + m√™s
- ‚úÖ Apenas para usu√°rios eleg√≠veis

---

## üìä KPIs e M√©tricas

### C√°lculos Principais

```typescript
// 1. MRR (Monthly Recurring Revenue)
const mrr = await prisma.pagamento.aggregate({
  where: {
    mesPagto: mesAtual,
    regraTipo: 'RECORRENTE',
  },
  _sum: { valor: true },
});

// 2. Churn Rate
const totalAtivos = await prisma.usuario.count({
  where: { statusFinal: 'ATIVO' },
});

const churns = await prisma.churn.count({
  where: { dataChurn: mesAtual },
});

const churnRate = (churns / totalAtivos) * 100;

// 3. Receita Total (m√™s)
const receitaTotal = await prisma.pagamento.aggregate({
  where: { mesPagto: mesAtual },
  _sum: { valor: true },
});

// 4. Despesa Total (m√™s)
const despesaTotal = await prisma.despesa.aggregate({
  where: {
    competenciaMes: mesAtual.getMonth() + 1,
    competenciaAno: mesAtual.getFullYear(),
  },
  _sum: { valor: true },
});

// 5. Lucro L√≠quido
const lucro = receitaTotal._sum.valor - despesaTotal._sum.valor;
```

---

## üéØ Pr√≥ximos Passos

- **Usu√°rios detalhado** ‚Üí [usuarios.md](./usuarios.md)
- **Pagamentos detalhado** ‚Üí [pagamentos.md](./pagamentos.md)
- **Agenda detalhado** ‚Üí [agenda.md](./agenda.md)
- **Churn detalhado** ‚Üí [churn.md](./churn.md)
- **Comiss√µes detalhado** ‚Üí [comissoes.md](./comissoes.md)

---

**√öltima atualiza√ß√£o:** 2025-10-29
